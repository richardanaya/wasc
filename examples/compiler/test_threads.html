<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WASC Thread Synchronization Test</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            max-width: 800px;
            margin: 50px auto;
            padding: 20px;
            background: #1e1e1e;
            color: #d4d4d4;
        }
        h1 { color: #4ec9b0; }
        .panel {
            background: #252526;
            border: 1px solid #3e3e42;
            padding: 20px;
            margin: 20px 0;
            border-radius: 5px;
        }
        button {
            background: #0e639c;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 14px;
            margin: 5px;
        }
        button:hover { background: #1177bb; }
        button:disabled { background: #3e3e42; cursor: not-allowed; }
        .success { color: #4ec9b0; }
        .error { color: #f48771; }
        .info { color: #569cd6; }
        pre {
            background: #1e1e1e;
            padding: 15px;
            border-radius: 3px;
            overflow-x: auto;
            border: 1px solid #3e3e42;
        }
        #log {
            max-height: 300px;
            overflow-y: auto;
            background: #1e1e1e;
            padding: 10px;
            border: 1px solid #3e3e42;
            font-family: 'Consolas', monospace;
            font-size: 13px;
        }
        .log-entry { margin: 5px 0; padding: 5px; border-left: 3px solid #4ec9b0; }
    </style>
</head>
<body>
    <h1>WASC Thread Synchronization Test</h1>
    
    <div class="panel">
        <h3>Test 1: Atomic Operations</h3>
        <pre>memory shared 1;

export i32 test_atomic() {
    i32 ptr = 0;
    atomic.store(ptr, 100);
    i32 val = atomic.load(ptr);
    i32 old = atomic.add(ptr, 50);
    return old;
}</pre>
        <button onclick="testAtomics()" id="testAtomicsBtn">Test Atomic Operations</button>
        <div id="atomicResult"></div>
    </div>

    <div class="panel">
        <h3>Test 2: Thread Notify</h3>
        <pre>memory shared 1;

export i32 test_notify() {
    i32 ptr = 0;
    i32 woken = thread.notify(ptr, 1);
    return woken;
}</pre>
        <button onclick="testNotify()" id="testNotifyBtn">Test Thread Notify</button>
        <div id="notifyResult"></div>
    </div>

    <div class="panel">
        <h3>Test 3: Thread Wait32</h3>
        <pre>memory shared 1;

export i32 test_wait() {
    i32 ptr = 0;
    i32 expected = 0;
    i64 timeout = 0;  // Don't wait (0 timeout)
    i32 result = thread.wait32(ptr, expected, timeout);
    return result;
}</pre>
        <button onclick="testWait()" id="testWaitBtn">Test Thread Wait32</button>
        <div id="waitResult"></div>
    </div>

    <div class="panel">
        <h3>Execution Log</h3>
        <div id="log"></div>
    </div>

    <script type="module">
        import init, { compile_wasm } from './wasc.js';
        
        let wasmModule = null;
        
        async function initWasm() {
            try {
                await init();
                wasmModule = { compile_wasm };
                log('✓ WASC compiler loaded');
            } catch (e) {
                log('✗ Error loading compiler: ' + e.message, 'error');
            }
        }
        
        function log(msg, type = 'info') {
            const logDiv = document.getElementById('log');
            const entry = document.createElement('div');
            entry.className = 'log-entry';
            entry.innerHTML = `<span class="${type}">${msg}</span>`;
            logDiv.appendChild(entry);
            logDiv.scrollTop = logDiv.scrollHeight;
        }
        
        async function compileAndRun(source, resultDivId) {
            const resultDiv = document.getElementById(resultDivId);
            
            if (!wasmModule) {
                resultDiv.innerHTML = '<span class="error">Compiler not loaded</span>';
                return null;
            }
            
            try {
                log('Compiling...');
                const bytes = wasmModule.compile_wasm(source);
                log(`✓ Compiled ${bytes.length} bytes`);
                
                // Check for shared memory requirement
                const wasmMod = await WebAssembly.compile(bytes);
                const imports = WebAssembly.Module.imports(wasmMod);
                log('Module imports: ' + imports.map(i => i.name).join(', '));
                
                // Create import object with shared memory
                const memory = new WebAssembly.Memory({ 
                    initial: 1, 
                    maximum: 1,
                    shared: true  // Required for atomics
                });
                
                const importObject = {
                    env: { memory }
                };
                
                log('Instantiating with shared memory...');
                const instance = await WebAssembly.instantiate(wasmMod, importObject);
                
                // Run main function
                const exports = Object.keys(instance.exports);
                log('Exports: ' + exports.join(', '));
                
                if (instance.exports.main) {
                    const result = instance.exports.main();
                    log(`✓ main() returned: ${result}`, 'success');
                    resultDiv.innerHTML = `<span class="success">✓ Success! main() returned ${result}</span>`;
                    return result;
                } else {
                    resultDiv.innerHTML = '<span class="error">No main export found</span>';
                    return null;
                }
                
            } catch (e) {
                log('✗ Error: ' + e.message, 'error');
                resultDiv.innerHTML = `<span class="error">✗ ${e.message}</span>`;
                return null;
            }
        }
        
        window.testAtomics = async function() {
            const source = `memory shared 1;

export i32 test_atomic() {
    i32 ptr = 0;
    atomic.store(ptr, 100);
    i32 val = atomic.load(ptr);
    i32 old = atomic.add(ptr, 50);
    return old;
}

export i32 main() {
    return test_atomic();
}`;
            await compileAndRun(source, 'atomicResult');
        };
        
        window.testNotify = async function() {
            const source = `memory shared 1;

export i32 test_notify() {
    i32 ptr = 0;
    i32 woken = thread.notify(ptr, 1);
    return woken;
}

export i32 main() {
    return test_notify();
}`;
            await compileAndRun(source, 'notifyResult');
        };
        
        window.testWait = async function() {
            const source = `memory shared 1;

export i32 test_wait() {
    i32 ptr = 0;
    i32 expected = 0;
    i64 timeout = 0;
    i32 result = thread.wait32(ptr, expected, timeout);
    return result;
}

export i32 main() {
    return test_wait();
}`;
            await compileAndRun(source, 'waitResult');
        };
        
        // Initialize
        initWasm();
    </script>
</body>
</html>
